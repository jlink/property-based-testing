# How to Specify it! in Java!

A couple of days ago [John Hughes](https://twitter.com/rjmh), 
one of the most prominent proponents of Property-based Testing, 
published [_How to Specify it!_](https://www.dropbox.com/s/tx2b84kae4bw1p4/paper.pdf).
In this paper he presents 
"five generic approaches to writing \[...\] specifications" a.k.a. properties.

Throughout the paper he uses [QuickCheck in Haskell](http://hackage.haskell.org/package/QuickCheck)
as tool and language of choice. Since many of my readers are not familiar with Haskell
I want to translate the examples into Java using [jqwik](https://jqwik.net)
as property testing library. 
[John was kind enough](https://twitter.com/rjmh/status/1147034204439490560) 
to allow me to use _his text_ enriched by my examples. John's original
text is set as a quotation. I'll sometimes leave out a few words or 
sentences that do not fit the Java context. 
I also replaced _QuickCheck_ with _jqwik_ in those places where applicable. 

Where necessary I will also add a few sentences of my own
to explain differences between the original and my code.


> ## 1 Introduction
>
> Searching for “property-based testing” on Youtube results in a lot of hits. Most of the top 100 consist of talks recorded at developer conferences and meetings, where (mostly) other people than this author present ideas, tools and methods for property-based testing, or applications that make use of it. Clearly, property-based testing is an idea whose time has come. But clearly, it is also poorly understood, requiring explanation over and over again!
>
> We have found that many developers trying property-based testing for the first time find it difficult to identify properties to write—and find the simple examples in tutorials difficult to generalize. This is known as the oracle problem, and it is common to all approaches that use test case generation.
>
> In this paper, therefore, we take a simple—but non-trivial—example of a purely functional data structure, and present five different approaches to writing properties, along with the pitfalls of each to keep in mind. We compare and contrast their effectiveness with the help of eight buggy implementations. We hope that the concrete advice presented here will enable readers to side-step the “where do I start?” question, and quickly derive the benefits that property-based testing has to offer.

> ## 2 A Primer in Property-Based Testing 
>
> Property-based testing is an approach to random testing pioneered by QuickCheck in Haskell. There is no precise definition of the term: indeed, MacIver [writes](https://hypothesis.works/articles/what-is-property-based-testing/):
> > ‘Historically the definition of property-based testing has been “The thing that QuickCheck does”.’
> The basic idea has been reimplemented many times — Wikipedia currently lists more than 50 implementations, in 36 different programming languages3, of all programming paradigms. These implementations vary in quality and features, but the ideas in this paper should be relevant to a user of any of them.
>
> Suppose, then, that we need to test the reverse function on lists. 

Since JDK's `Collections.reverse` method changes the original list in place we'll wrap it with a copying method. So here's the reverse method
that we actually use for testing:

```java
List<T> reverse(List<T> original) {
    List<T> clone = new ArrayList<>(original);
    Collections.reverse(clone);
    return clone;
}
```

> Any developer will be able to write a unit test such as the following:

```java
@Example 
boolean reverseList() {
    List<Integer> aList = asList(1, 2, 3);
    return reverse(aList).equals(asList(3, 2, 1));
} 
```

> This test is written in the same form as most test cases worldwide: we apply the function under test (reverse) to known arguments (1,2,3), and then com- pare the result to a known expected value (3,2,1). Developers are practiced in coming up with these examples, and predicting expected results. But what happens when we try to write a property instead?

```java
@Property
boolean reverseList(@ForAll List<Integer> aList) {
    return reverse(aList).equals(???);
} 
```

> The property is parameterised on `aList`, which will be randomly generated by _jqwik_ \[...\].
>
> The property can clearly test reverse in a much wider range of cases than the unit test—any randomly generated list, rather than just the list [1,2,3] — which is a great advantage. But the question is: what is the expected result? That is, what should we replace `???` by in the definition above? Since the argument to reverse is not known in advance, we cannot precompute the expected result. We could write test code to predict it, as in

```java
@Property
boolean reverseList(@ForAll List<Integer> aList) {
    return reverse(aList).equals(predictRev(aList));
} 
```

> but `predictRev` is not easier to write than reverse — it is exactly the same function!
>
> This is the most obvious approach to writing properties—to replicate the implementation in the test code — and it is deeply unsatisfying. It is both an expensive approach, because the replica of the implementation may be as complex as the implementation under test, and of low value, because there is a grave risk that misconceptions in the implementation will be replicated in the test code. “Expensive” and “low value” is an unfortunate combination of characteristics for a software testing method, and all too often leads developers to abandon property-based testing altogether.
>
> We can finesse the problem by rewriting the property so that it does not refer to an expected result, instead checking some property of the result. For example, reverse is its own inverse:

```java
@Property
boolean reverseTwiceIsOriginal(@ForAll List<Integer> aList) {
    return reverse(reverse(aList)).equals(aList);
} 
```

> Now we can pass the property to _jqwik_, to run a series of random tests (by default 1000):

```text
timestamp = 2019-07-06T14:54:35.722, ListReverseProperties:reverseTwiceIsOriginal =
 
tries = 1000         | # of calls to property
checks = 1000        | # of not rejected calls
```

> We have met our goal of testing reverse on 1000 random lists, but this property is not very strong — if we had accidentally defined

```java
List<T> reverse(List<T> list) {
    return list;
} 
```

> then it would still pass (whereas the unit test above would report a bug).
> 
> We can define another property that this buggy implementation of reverse
passes, but the correct definition fails:

```java
@Property
boolean reverseKeepsTheOriginalList(@ForAll List<Integer> aList) {
    return reverse(aList).equals(aList);
} 
```

```
org.opentest4j.AssertionFailedError: Property [ListReverseProperties:reverseKeepsTheOriginalList] falsified with sample [[0, -1]]

tries = 2                     | # of calls to property
checks = 2                    | # of not rejected calls
sample = [[0, -1]]
```

> Here the `sample` line shows the value of `aList` for which the test failed (0, -1) \[...\].
>
> Interestingly, the counterexample _jqwik_ reports for this property is always (0, -1) or (0, 1). These are not the random counterexamples that _jqwik_ finds first; they are the result of shrinking the random counterexamples via a systematic greedy search for a simpler failing test. Shrinking lists tries to remove elements, and numbers shrink towards zero; the reason we see these two counterexamples is that xs must contain at least two different elements to falsify the property, and 0 and 1/-1 are the smallest pair of different integers. Shrinking is one of the most useful features of property-based testing, resulting in counterexamples which are usually easy to debug, because every part of the counterexample is relevant to the failure.
>
> Now we have seen the benefits of property-based testing—random generation of very many test cases, and shrinking of counterexamples to minimal failing tests—and the major pitfall: the temptation to replicate the implementation in the tests, incurring high costs for little benefit. In the remainder of this paper, we present systematic ways to define properties without falling into this trap. We will (largely) ignore the question of how to generate effective test cases—that are good at reaching buggy behaviour in the implementation under test—because in the absence of good properties, good generators are of little value.
