# How to Specify it! in Java!

A couple of days ago [John Hughes](https://twitter.com/rjmh), 
the most prominent proponent of Property-based Testing, 
published [_How to Specify it!_](https://www.dropbox.com/s/tx2b84kae4bw1p4/paper.pdf).
In this paper he presents 
"five generic approaches to writing \[...\] specifications" a.k.a. properties.

Throughout the paper he uses [QuickCheck in Haskell](http://hackage.haskell.org/package/QuickCheck)
as tool and language of choice. Since some of my readers are not familiar with Haskell
I want to transfer the examples into Java using [jqwik](https://jqwik.net)
as property testing library. 
[John was kind enough](https://twitter.com/rjmh/status/1147034204439490560) 
to allow me to use _his text_ enriched by my examples. John's original
text is formatted 

> as a quotation. 

I'll sometimes leave out a few words or 
sentences that do not fit the Java context. 
I also replaced _QuickCheck_ with _jqwik_ in those places where applicable. 

Where necessary I will add a few sentences of my own
to explain differences between the original and my translated version.


> ## 1 Introduction
>
> Searching for “property-based testing” on Youtube results in a lot of hits. Most of the top 100 consist of talks recorded at developer conferences and meetings, where (mostly) other people than this author present ideas, tools and methods for property-based testing, or applications that make use of it. Clearly, property-based testing is an idea whose time has come. But clearly, it is also poorly understood, requiring explanation over and over again!
>
> We have found that many developers trying property-based testing for the first time find it difficult to identify properties to write — and find the simple examples in tutorials difficult to generalize. This is known as the oracle problem, and it is common to all approaches that use test case generation.
>
> In this paper, therefore, we take a simple — but non-trivial — example of a purely functional data structure, and present five different approaches to writing properties, along with the pitfalls of each to keep in mind. We compare and contrast their effectiveness with the help of eight buggy implementations. We hope that the concrete advice presented here will enable readers to side-step the “where do I start?” question, and quickly derive the benefits that property-based testing has to offer.

> ## 2 A Primer in Property-Based Testing 
>
> Property-based testing is an approach to random testing pioneered by QuickCheck in Haskell. There is no precise definition of the term: indeed, MacIver [writes](https://hypothesis.works/articles/what-is-property-based-testing/):
> > ‘Historically the definition of property-based testing has been “The thing that QuickCheck does”.’
> The basic idea has been reimplemented many times — Wikipedia currently lists more than 50 implementations, in 36 different programming languages3, of all programming paradigms. These implementations vary in quality and features, but the ideas in this paper should be relevant to a user of any of them.
>
> Suppose, then, that we need to test the reverse function on lists. 

Since JDK's `Collections.reverse` method changes the original list in place we'll wrap it with a copying method. So here's the reverse method
that we actually use for testing:

```java
List<T> reverse(List<T> original) {
    List<T> clone = new ArrayList<>(original);
    Collections.reverse(clone);
    return clone;
}
```

> Any developer will be able to write a unit test such as the following:

```java
@Example 
boolean reverseList() {
    List<Integer> aList = asList(1, 2, 3);
    return reverse(aList).equals(asList(3, 2, 1));
} 
```

`@Example` is _jqwik's_ equivalent to JUnit's `@Test`. Moreover it allows
to return a boolean value to state success or failure of a test. For
more complicated checks the assertion style of most Java test libraries
is also supported.

> This test is written in the same form as most test cases worldwide: we apply the function under test (reverse) to known arguments (1,2,3), and then com- pare the result to a known expected value (3,2,1). Developers are practiced in coming up with these examples, and predicting expected results. But what happens when we try to write a property instead?

```java
@Property
boolean reverseList(@ForAll List<Integer> aList) {
    return reverse(aList).equals(???);
} 
```

> The property is parameterised on `aList`, which will be randomly generated by _jqwik_ \[...\].
>
> The property can clearly test reverse in a much wider range of cases than the unit test—any randomly generated list, rather than just the list [1,2,3] — which is a great advantage. But the question is: what is the expected result? That is, what should we replace `???` by in the definition above? Since the argument to reverse is not known in advance, we cannot precompute the expected result. We could write test code to predict it, as in

```java
@Property
boolean reverseList(@ForAll List<Integer> aList) {
    return reverse(aList).equals(predictRev(aList));
} 
```

> but `predictRev` is not easier to write than reverse — it is exactly the same function!
>
> This is the most obvious approach to writing properties—to replicate the implementation in the test code — and it is deeply unsatisfying. It is both an expensive approach, because the replica of the implementation may be as complex as the implementation under test, and of low value, because there is a grave risk that misconceptions in the implementation will be replicated in the test code. “Expensive” and “low value” is an unfortunate combination of characteristics for a software testing method, and all too often leads developers to abandon property-based testing altogether.
>
> We can finesse the problem by rewriting the property so that it does not refer to an expected result, instead checking some property of the result. For example, reverse is its own inverse:

```java
@Property
boolean reverseTwiceIsOriginal(@ForAll List<Integer> aList) {
    return reverse(reverse(aList)).equals(aList);
} 
```

> Now we can pass the property to _jqwik_, to run a series of random tests (by default 1000):

```text
timestamp = 2019-07-06T14:54:35.722, ListReverseProperties:reverseTwiceIsOriginal =
 
tries = 1000         | # of calls to property
checks = 1000        | # of not rejected calls
```

> We have met our goal of testing reverse on 1000 random lists, but this property is not very strong — if we had accidentally defined

```java
List<T> reverse(List<T> list) {
    return list;
} 
```

> then it would still pass (whereas the unit test above would report a bug).
> 
> We can define another property that this buggy implementation of reverse
passes, but the correct definition fails:

```java
@Property
boolean reverseKeepsTheOriginalList(@ForAll List<Integer> aList) {
    return reverse(aList).equals(aList);
} 
```

```
AssertionFailedError: Property [ListReverseProperties:reverseKeepsTheOriginalList] falsified with sample [[0, -1]]

tries = 2                     | # of calls to property
checks = 2                    | # of not rejected calls
sample = [[0, -1]]
```

Here the `sample` line shows the value of `aList` for which the test failed: (0, -1).

> Interestingly, the counterexample _jqwik_ reports for this property is always (0, -1) or (0, 1). These are not the random counterexamples that _jqwik_ finds first; they are the result of shrinking the random counterexamples via a systematic greedy search for a simpler failing test. Shrinking lists tries to remove elements, and numbers shrink towards zero; the reason we see these two counterexamples is that xs must contain at least two different elements to falsify the property, and 0 and 1/-1 are the smallest pair of different integers. Shrinking is one of the most useful features of property-based testing, resulting in counterexamples which are usually easy to debug, because every part of the counterexample is relevant to the failure.
>
> Now we have seen the benefits of property-based testing — random generation of very many test cases, and shrinking of counterexamples to minimal failing tests — and the major pitfall: the temptation to replicate the implementation in the tests, incurring high costs for little benefit. In the remainder of this paper, we present systematic ways to define properties without falling into this trap. We will (largely) ignore the question of how to generate effective test cases—that are good at reaching buggy behaviour in the implementation under test — because in the absence of good properties, good generators are of little value.

> ## 3 Our Running Example: Binary Search Trees
>
> The code we shall develop properties for is an implementation of finite maps (from keys to values) as binary search trees. 

Here's the public interface of class 
[`BST`](https://github.com/jlink/property-based-testing/blob/master/pbt-java/src/test/java/how_to_specify_it/bst/BST.java):

```java
public class BST<K extends Comparable<K>, V> {
    public static <K extends Comparable<K>, V> BST<K, V> nil();
    public static <K extends Comparable<K>, V> BST<K, V> union(BST<K, V> bst1, BST<K, V> bst2);
       
    public K key();
    public V value();
    public Optional<BST<K, V>> left();
    public Optional<BST<K, V>> right();
    public boolean isEmpty();
    public boolean isLeaf();
    public int size();
       
    public Optional<V> find(K key);
    public BST<K, V> insert(K key, V value);
    public BST<K, V> delete(K key);
    public List<K> keys();
    public List<Map.Entry<K, V>> toList();
}
```

The method names were chosen to resemble the Haskell version as much as possible. 
Moreover, the implementation follows a pattern rather unusual in Java: 
Every instance of a `BST` is immutable, i.e. the changing methods - `insert`, `delete` and `union` - return a new instance of `BST`. 
An empty instance can be accessed through `BST.nil()`.

> The operations we will test are those that create trees (nil, insert, delete and union), and that find the value associated with a key in the tree. We will also use auxiliary operations: toList, which returns a sorted list of the key-value pairs in the tree, and keys which is defined in terms of it. The implementation itself is standard, and is not included here.
>
> Before writing properties of binary search trees, we must define a generator: 

```java
import net.jqwik.api.Tuple.*;

@Provide
Arbitrary<BST<Integer, Integer>> trees() {
    Arbitrary<Integer> keys = Arbitraries.integers();
    Arbitrary<Integer> values = Arbitraries.integers();
    Arbitrary<List<Tuple2<Integer, Integer>>> keysAndValues =
            Combinators.combine(keys, values).as(Tuple::of).list();
    
    // This could be implemented as streaming and reducing
    // but that'd probably be less understandable
    return keysAndValues.map(keyValueList -> {
        BST<Integer, Integer> bst = BST.nil();
        for (Tuple2<Integer, Integer> kv : keyValueList) {
            bst = bst.insert(kv.get1(), kv.get2());
        }
        return bst;
    });
}
```

_Generators_ have type `Arbitrary` in _jqwik_; they are usually fed
to properties through methods annotated with `@Provide`. 
Shrinking behaviour is also automatically derived.

> We need to fix an instance type for testing; for the time being, we choose to let both keys and values be integers. `Integer` is usually an acceptably good choice as an instance for testing polymorphic properties, although we will return to this choice later.

Strictly speaking this would not be necessary for _jqwik_ since the framework
can randomly choose any type that's compatible with the generic type
definition. To be closer to the original version I went with `Integer` nonetheless.

> ## 4 Approaches to Writing Properties
> ### 4.1 Validity Testing
>
> Like many data-structures, binary search trees satisfy an important invariant— and so we can write properties to test that the invariant is preserved.
>
> In this case the invariant is captured by the 
> [following function](https://github.com/jlink/property-based-testing/blob/master/pbt-java/src/test/java/how_to_specify_it/bst/BSTValidity.java#L8):

```java
boolean isValid(BST bst) {
    if (bst.isLeaf()) {
        return true;
    }
    return isValid(bst.left()) 
             && isValid(bst.right())
             && keys(bst.left()).allMatch(k -> k.compareTo(bst.key()) < 0)
             && keys(bst.right()).allMatch(k -> k.compareTo(bst.key()) > 0);
}
```
I left out the generic types and the code of two subfunctions. 

> That is, all the keys in a left subtree must be less than the key in the node, and all the keys in the right subtree must be greater.
>
> This definition is obviously correct, but also inefficient: it is quadratic in the size of the tree in the worst case. A more efficient definition would exploit the validity of the left and right subtrees, and compare only the last key in the left subtree, and the first key in the right subtree, against the key in a Branch node. But the equivalence of these two definitions depends on reasoning, and we prefer to avoid reasoning that is not checked by tests — if it turns out to be wrong, or is invalidated by later changes to the code, then tests using the more efficient definition might fail to detect some bugs. Testing that two definitions are equivalent would require testing a property such as

```java
@Property
boolean valid_and_fastValid_are_equivalent(@ForAll("trees") BST bst) {
    return valid(bst) == fastValid(bst);
}
``` 

> and to do so, we would need a generator that can produce both valid and invalid trees, so this is not a straightforward extension. We prefer, therefore, to use the obvious-but-inefficient definition, at least initially.
>
> Now it is straightforward to define properties that check that every operation that constructs a tree, constructs a valid one:

```java
@Example
boolean nil_is_valid() {
    BST<Integer, Integer> nil = BST.nil();
    return isValid(nil);
}

@Property
boolean insert_valid(
        @ForAll("trees") BST<Integer, Integer> bst,
        @ForAll Integer key
) {
    return isValid(bst.insert(key, 42));
}

@Property
boolean delete_valid(
        @ForAll("trees") BST<Integer, Integer> bst,
        @ForAll Integer key
) {
    return isValid(bst.delete(key));
}

@Property
boolean union_valid(
        @ForAll("trees") BST<Integer, Integer> bst,
        @ForAll("trees") BST<Integer, Integer> other
) {
    return isValid(BST.union(bst, other));
}
``` 

> However, these properties, by themselves, do not provide good testing for validity. To see why, let us plant a bug in insert, so that it creates duplicate entries when inserting a key that is already present (bug (2) in section 5). Property `insert_valid` fails as it should, but so do `delete_valid` and `union_valid`:

```
AssertionFailedError: Property [BST Properties:insert valid] falsified with sample 
[0=0
left:  NIL
right: 0=0
       left:  NIL
       right: NIL, 
0]
       
AssertionFailedError: Property [BST Properties:delete valid] falsified with sample 
[0=0
left:  NIL
right: 0=0
       left:  NIL
       right: NIL, 
-1]   
       
AssertionFailedError: Property [BST Properties:union valid] falsified with sample 
[2=0
    left:  NIL
    right: NIL, 
2=0
    left:  NIL
    right: NIL]
``` 

> Thus, at first sight, there is nothing to indicate that the bug is in insert; all of insert, delete and union can return invalid trees! However, delete and union are given invalid trees as inputs in the tests above, and we cannot expect them to return valid trees in this case, so these reported failures are “false positives”.
>
> The problem here is that the generator for trees is producing invalid ones (because it is defined in terms of insert). We could add a precondition to each property, requiring the tree to be valid, as in:

```java
@Property
boolean delete_valid(
        @ForAll("trees") BST<Integer, Integer> bst,
        @ForAll Integer key
) {
    Assume.that(isValid(bst));
    return isValid(bst.delete(key));
}
```

> which would discard invalid test cases (not satisfying the precondition) without running them, and thus make the properties pass. This is potentially inefficient (we might spend much of our testing time discarding test cases), but it is also really just applying a sticking plaster: what we want is that all generated trees should be valid! We can test this by defining an additional property:

```java
@Property
boolean arbitrary_valid(@ForAll("trees") BST<Integer, Integer> bst) {
    return isValid(bst);
}
```

> which at first sight seems to be testing that all trees are valid, but in fact tests that all trees generated by the Arbitrary instance are valid. If this property fails, then it is the generator that needs to be fixed—there is no point in looking at failures of other properties, as they are likely caused by the failing generator.
> 
> Usually the generator for a type is intended to fulfill its invariant, but — as in this case — is defined independently. A property such as `arbitrary_valid` is essential to check that these definitions are mutually consistent.

At this point 
[in the original paper](https://www.dropbox.com/s/tx2b84kae4bw1p4/paper.pdf)
there is almost a full page discussing problems in shrinking that lead
to invalid shrunk data. However, this is not an issue in _jqwik's_
implementation. In general, _jqwik_ supports
[integrated shrinking](https://jqwik.net/docs/current/user-guide.html#integrated-shrinking);
thereby all preconditions added during data generation will also be
preserved while shrinking. 

> This section illustrates well the importance of testing our tests; it is vital to test generators and shrinkers independently of the operations under test, because a bug in either can result in very many hard-to-debug failures in other properties.
>
> Validity properties are important to test, whenever a datatype has an invariant, but they are far from sufficient by themselves. Consider this: if every function returning a BST were defined to return nil in every case, then all the properties written so far would pass. insert could be defined to delete the key instead, or union could be defined to implement set difference — as long as the invariant is preserved, the properties will still pass. Thus we must move on to properties that better capture the intended behaviour of each operation.

> ### 4.2 Postconditions
>
> A postcondition is a property that should be True after a call, or (equivalently, for a pure function) True of its result. Thus we can define properties by asking ourselves “What should be True after calling f ?”. For example, after calling insert, then we should be able to find the key just inserted, and any previously inserted keys with unchanged values.

```java
@Property
boolean insert_post(
        @ForAll Integer key, @ForAll Integer value,
        @ForAll("trees") BST<Integer, Integer> bst,
        @ForAll Integer otherKey
) {
    Optional<Integer> found = bst.insert(key, value).find(otherKey);
    if (otherKey.equals(key)) {
        return found.map(v -> v.equals(value)).orElse(false);
    } else {
        return found.equals(bst.find(otherKey));
    }
}
```

> One may wonder whether it is best to parameterize this property on two different keys, or just on one: after all, for the type chosen, k and k′ are equal in only around 3.3% of tests, so most test effort is devoted to checking that other keys than the one inserted are preserved. However, using the same key for k and k′ would weaken the property drastically — for example, an implementation of insert that discarded the original tree entirely would still pass. Moreover, nothing hinders us from defining and testing a specialized property:

```java
@Property
boolean insert_post_same_key(
        @ForAll Integer key, @ForAll Integer value,
        @ForAll("trees") BST<Integer, Integer> bst
) {
    return insert_post(key, value, bst, key);
}
```

> Testing this property devotes all test effort to the case of finding a newly inserted key, but does not require us to replicate the logic in the more general postcondition.
>
> We can write similar postconditions for delete and union; writing the property for union forces us to specify that union is left-biased (since union of finite maps cannot be commutative).

```java
@Property
boolean union_post(
        @ForAll("trees") BST<Integer, Integer> left,
        @ForAll("trees") BST<Integer, Integer> right,
        @ForAll Integer key
) {
    BST<Integer, Integer> union = BST.union(left, right);
    Integer previousValue = left.find(key).orElse(right.find(key).orElse(null));
    Integer unionValue = union.find(key).orElse(null);
    return Objects.equals(unionValue, previousValue);
}
```