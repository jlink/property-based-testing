# How to Specify it! in Java!

A couple of days ago [John Hughes](https://twitter.com/rjmh), 
one of the most prominent proponents of Property-based Testing, 
published [_How to Specify it!_](https://www.dropbox.com/s/tx2b84kae4bw1p4/paper.pdf).
In this paper he presents 
"five generic approaches to writing \[...\] specifications" a.k.a. properties.

Throughout the paper he uses [QuickCheck in Haskell](http://hackage.haskell.org/package/QuickCheck)
as tool and language of choice. Since many of my readers are not familiar with Haskell
I want to translate the examples into Java using [jqwik](https://jqwik.net)
as property testing library. 
[John was kind enough](https://twitter.com/rjmh/status/1147034204439490560) 
to allow me to use _his text_ enriched by my examples. John's original
text is set as a quotation. I'll sometimes leave out a few words or 
sentences that do not fit the Java context. 
I also replaced _QuickCheck_ with _jqwik_ in those places where applicable. 

Where necessary I will also add a few sentences of my own
to explain differences between the original and my code.


> ## 1 Introduction
>
> Searching for “property-based testing” on Youtube results in a lot of hits. Most of the top 100 consist of talks recorded at developer conferences and meetings, where (mostly) other people than this author present ideas, tools and methods for property-based testing, or applications that make use of it. Clearly, property-based testing is an idea whose time has come. But clearly, it is also poorly understood, requiring explanation over and over again!
>
> We have found that many developers trying property-based testing for the first time find it difficult to identify properties to write — and find the simple examples in tutorials difficult to generalize. This is known as the oracle problem, and it is common to all approaches that use test case generation.
>
> In this paper, therefore, we take a simple — but non-trivial — example of a purely functional data structure, and present five different approaches to writing properties, along with the pitfalls of each to keep in mind. We compare and contrast their effectiveness with the help of eight buggy implementations. We hope that the concrete advice presented here will enable readers to side-step the “where do I start?” question, and quickly derive the benefits that property-based testing has to offer.

> ## 2 A Primer in Property-Based Testing 
>
> Property-based testing is an approach to random testing pioneered by QuickCheck in Haskell. There is no precise definition of the term: indeed, MacIver [writes](https://hypothesis.works/articles/what-is-property-based-testing/):
> > ‘Historically the definition of property-based testing has been “The thing that QuickCheck does”.’
> The basic idea has been reimplemented many times — Wikipedia currently lists more than 50 implementations, in 36 different programming languages3, of all programming paradigms. These implementations vary in quality and features, but the ideas in this paper should be relevant to a user of any of them.
>
> Suppose, then, that we need to test the reverse function on lists. 

Since JDK's `Collections.reverse` method changes the original list in place we'll wrap it with a copying method. So here's the reverse method
that we actually use for testing:

```java
List<T> reverse(List<T> original) {
    List<T> clone = new ArrayList<>(original);
    Collections.reverse(clone);
    return clone;
}
```

> Any developer will be able to write a unit test such as the following:

```java
@Example 
boolean reverseList() {
    List<Integer> aList = asList(1, 2, 3);
    return reverse(aList).equals(asList(3, 2, 1));
} 
```

`@Example` is _jqwik's_ equivalent to JUnit's `@Test`. Moreover it allows
to return a boolean value to state success or failure of a test. For
more complicated checks the assertion style of most Java test libraries
is also supported.

> This test is written in the same form as most test cases worldwide: we apply the function under test (reverse) to known arguments (1,2,3), and then com- pare the result to a known expected value (3,2,1). Developers are practiced in coming up with these examples, and predicting expected results. But what happens when we try to write a property instead?

```java
@Property
boolean reverseList(@ForAll List<Integer> aList) {
    return reverse(aList).equals(???);
} 
```

> The property is parameterised on `aList`, which will be randomly generated by _jqwik_ \[...\].
>
> The property can clearly test reverse in a much wider range of cases than the unit test—any randomly generated list, rather than just the list [1,2,3] — which is a great advantage. But the question is: what is the expected result? That is, what should we replace `???` by in the definition above? Since the argument to reverse is not known in advance, we cannot precompute the expected result. We could write test code to predict it, as in

```java
@Property
boolean reverseList(@ForAll List<Integer> aList) {
    return reverse(aList).equals(predictRev(aList));
} 
```

> but `predictRev` is not easier to write than reverse — it is exactly the same function!
>
> This is the most obvious approach to writing properties—to replicate the implementation in the test code — and it is deeply unsatisfying. It is both an expensive approach, because the replica of the implementation may be as complex as the implementation under test, and of low value, because there is a grave risk that misconceptions in the implementation will be replicated in the test code. “Expensive” and “low value” is an unfortunate combination of characteristics for a software testing method, and all too often leads developers to abandon property-based testing altogether.
>
> We can finesse the problem by rewriting the property so that it does not refer to an expected result, instead checking some property of the result. For example, reverse is its own inverse:

```java
@Property
boolean reverseTwiceIsOriginal(@ForAll List<Integer> aList) {
    return reverse(reverse(aList)).equals(aList);
} 
```

> Now we can pass the property to _jqwik_, to run a series of random tests (by default 1000):

```text
timestamp = 2019-07-06T14:54:35.722, ListReverseProperties:reverseTwiceIsOriginal =
 
tries = 1000         | # of calls to property
checks = 1000        | # of not rejected calls
```

> We have met our goal of testing reverse on 1000 random lists, but this property is not very strong — if we had accidentally defined

```java
List<T> reverse(List<T> list) {
    return list;
} 
```

> then it would still pass (whereas the unit test above would report a bug).
> 
> We can define another property that this buggy implementation of reverse
passes, but the correct definition fails:

```java
@Property
boolean reverseKeepsTheOriginalList(@ForAll List<Integer> aList) {
    return reverse(aList).equals(aList);
} 
```

```
org.opentest4j.AssertionFailedError: Property [ListReverseProperties:reverseKeepsTheOriginalList] falsified with sample [[0, -1]]

tries = 2                     | # of calls to property
checks = 2                    | # of not rejected calls
sample = [[0, -1]]
```

Here the `sample` line shows the value of `aList` for which the test failed (0, -1).

> Interestingly, the counterexample _jqwik_ reports for this property is always (0, -1) or (0, 1). These are not the random counterexamples that _jqwik_ finds first; they are the result of shrinking the random counterexamples via a systematic greedy search for a simpler failing test. Shrinking lists tries to remove elements, and numbers shrink towards zero; the reason we see these two counterexamples is that xs must contain at least two different elements to falsify the property, and 0 and 1/-1 are the smallest pair of different integers. Shrinking is one of the most useful features of property-based testing, resulting in counterexamples which are usually easy to debug, because every part of the counterexample is relevant to the failure.
>
> Now we have seen the benefits of property-based testing — random generation of very many test cases, and shrinking of counterexamples to minimal failing tests — and the major pitfall: the temptation to replicate the implementation in the tests, incurring high costs for little benefit. In the remainder of this paper, we present systematic ways to define properties without falling into this trap. We will (largely) ignore the question of how to generate effective test cases—that are good at reaching buggy behaviour in the implementation under test — because in the absence of good properties, good generators are of little value.

> ## 3 Our Running Example: Binary Search Trees
>
> The code we shall develop properties for is an implementation of finite maps (from keys to values) as binary search trees. 

Here's the interface of class 
[`BST`](https://github.com/jlink/property-based-testing/blob/master/pbt-java/src/test/java/how_to_specify_it/bst/BST.java):

```java
public class BST<K extends Comparable<K>, V> {
    public static <K extends Comparable<K>, V> BST<K, V> nil();
    public static <K extends Comparable<K>, V> BST<K, V> union(BST<K, V> bst1, BST<K, V> bst2);
       
    public K key();
    public V value();
    public Optional<BST<K, V>> left();
    public Optional<BST<K, V>> right();
    public boolean isEmpty();
    public boolean isLeaf();
    public int size();
       
    public Optional<V> find(K key);
    public BST<K, V> insert(K key, V value);
    public BST<K, V> delete(K key);
    public List<K> keys();
    public List<Map.Entry<K, V>> toList();
}
```

The method names were chosen to resemble the Haskell version as much as possible. 
Moreover, the implementation follows a pattern rather unusual in Java: 
Every instance of a `BST` is immutable, i.e. the changing methods - `insert`, `delete` and `union` - return a new instance of `BST`. 
The initial empty instance can be accessed through `BST.nil()`.

> The operations we will test are those that create trees (nil, insert, delete and union), and that find the value associated with a key in the tree. We will also use auxiliary operations: toList, which returns a sorted list of the key-value pairs in the tree, and keys which is defined in terms of it. The implementation itself is standard, and is not included here.
>
> Before writing properties of binary search trees, we must define a generator: 

```java
@Provide
Arbitrary<BST<Integer, Integer>> bsts() {
    Arbitrary<List<Integer>> keys = Arbitraries.integers().list();
    return keys.flatMap(keyList -> {
        Arbitrary<List<Integer>> values = Arbitraries.integers().list().ofSize(keyList.size());
        return values.map(valuesList -> {
            BST<Integer, Integer> bst = BST.nil();
            for (int i = 0; i < keyList.size(); i++) {
                Integer key = keyList.get(i);
                Integer value = valuesList.get(i);
                bst = bst.insert(key, value);
            }
            return bst;
        });
    });
}
```

_Generators_ have type `Arbitrary` in _jqwik_; they are usually fed
to properties through methods annotated with `@Provide`. 
Shrinking behaviour is also automatically derived.

> We need to fix an instance type for testing; for the time being, we choose to let both keys and values be integers. `Integer` is usually an acceptably good choice as an instance for testing polymorphic properties, although we will return to this choice later.

Strictly speaking this would not necessary for _jqwik_ since the framework
can randomly choose any type that's compatible with the generic type
definition. To be closer to the original version I went with `Integer` as well.

> ## 4 Approaches to Writing Properties
> ### 4.1 Validity Testing
>
> Like many data-structures, binary search trees satisfy an important invariant— and so we can write properties to test that the invariant is preserved.
>
> In this case the invariant is captured by the 
> [following function](https://github.com/jlink/property-based-testing/blob/master/pbt-java/src/test/java/how_to_specify_it/bst/BSTValidity.java#L8):

```java
boolean isValid(BST bst) {
    if (bst.isLeaf()) {
        return true;
    }
    return isValid(bst.left()) 
             && isValid(bst.right())
             && keys(bst.left()).allMatch(k -> k.compareTo(bst.key()) < 0)
             && keys(bst.right()).allMatch(k -> k.compareTo(bst.key()) > 0);
}
```
I left out the generic types and the code of two subfunctions. 

> That is, all the keys in a left subtree must be less than the key in the node, and all the keys in the right subtree must be greater.
>
> This definition is obviously correct, but also inefficient: it is quadratic in the size of the tree in the worst case. A more efficient definition would exploit the validity of the left and right subtrees, and compare only the last key in the left subtree, and the first key in the right subtree, against the key in a Branch node. But the equivalence of these two definitions depends on reasoning, and we prefer to avoid reasoning that is not checked by tests—if it turns out to be wrong, or is invalidated by later changes to the code, then tests using the more efficient definition might fail to detect some bugs. Testing that two definitions are equivalent would require testing a property such as

```java
@Property
boolean valid_and_fastValid_are_equivalent(@ForAll("trees") BST bst) {
    return valid(bst) == fastValid(bst);
}
``` 

> and to do so, we would need a generator that can produce both valid and invalid trees, so this is not a straightforward extension. We prefer, therefore, to use the obvious-but-inefficient definition, at least initially.